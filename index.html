<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">LilyMeng's Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a class="nav-icon" style="width: 46px" href="https://github.com/liyuan-meng" target="_blank">Github</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Socket.io/client/2. Initialization" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/Socket.io/client/2.%20Initialization/" class="article-date">
  <time datetime="2020-08-30T07:46:37.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/Socket.io/client/2.%20Initialization/">Initialization</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Once you have <a href="https://socket.io/docs/client-installation/" target="_blank" rel="noopener">installed</a> the Socket.IO client library, you can now init the client. The complete list of options can be found <a href="https://socket.io/docs/client-api/#new-Manager-url-options" target="_blank" rel="noopener">here</a>.</p>
<p>In the examples below, the <code>io</code> object comes either from:</p>
<p>一旦安装了Socket.IO客户端库，就可以初始化客户端。 选项的完整列表可以在这里找到。</p>
<p>在以下示例中，io对象来自：</p>
<ul>
<li>the <script> import</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>NPM</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 import</span></span><br><span class="line"><span class="keyword">import</span> io <span class="keyword">from</span> <span class="string">'socket.io-client'</span>;</span><br><span class="line"><span class="comment">// CommonJS</span></span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io-client'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="From-the-same-domain"><a href="#From-the-same-domain" class="headerlink" title="From the same domain"></a>From the same domain</h2><p>If your front is served on the same domain as your server, you can simply use:</p>
<p>如果您的前台与服务器位于同一域中，则可以简单地使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io();</span><br></pre></td></tr></table></figure>

<p>The server URL will be deduced from the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/location" target="_blank" rel="noopener">window.location</a> object.</p>
<p>Additional options can be passed:</p>
<p>服务器URL将从window.location对象推导出。</p>
<p>可以传递其他选项：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default values</span></span><br><span class="line"><span class="keyword">const</span> socket = io(&#123;</span><br><span class="line">  path: <span class="string">'/socket.io'</span>,</span><br><span class="line">  reconnection: <span class="literal">true</span>,</span><br><span class="line">  reconnectionAttempts: <span class="literal">Infinity</span>,</span><br><span class="line">  reconnectionDelay: <span class="number">1000</span>,</span><br><span class="line">  reconnectionDelayMax: <span class="number">5000</span>,</span><br><span class="line">  randomizationFactor: <span class="number">0.5</span>,</span><br><span class="line">  timeout: <span class="number">20000</span>,</span><br><span class="line">  autoConnect: <span class="literal">true</span>,</span><br><span class="line">  query: &#123;&#125;,</span><br><span class="line">  <span class="comment">// options of the Engine.IO client</span></span><br><span class="line">  upgrade: <span class="literal">true</span>,</span><br><span class="line">  forceJSONP: <span class="literal">false</span>,</span><br><span class="line">  jsonp: <span class="literal">true</span>,</span><br><span class="line">  forceBase64: <span class="literal">false</span>,</span><br><span class="line">  enablesXDR: <span class="literal">false</span>,</span><br><span class="line">  timestampRequests: <span class="literal">true</span>,</span><br><span class="line">  timestampParam: <span class="string">'t'</span>,</span><br><span class="line">  policyPort: <span class="number">843</span>,</span><br><span class="line">  transports: [<span class="string">'polling'</span>, <span class="string">'websocket'</span>],</span><br><span class="line">  transportOptions: &#123;&#125;,</span><br><span class="line">  rememberUpgrade: <span class="literal">false</span>,</span><br><span class="line">  onlyBinaryUpgrades: <span class="literal">false</span>,</span><br><span class="line">  requestTimeout: <span class="number">0</span>,</span><br><span class="line">  protocols: [],</span><br><span class="line">  <span class="comment">// options for Node.js</span></span><br><span class="line">  agent: <span class="literal">false</span>,</span><br><span class="line">  pfx: <span class="literal">null</span>,</span><br><span class="line">  key: <span class="literal">null</span>,</span><br><span class="line">  passphrase: <span class="literal">null</span>,</span><br><span class="line">  cert: <span class="literal">null</span>,</span><br><span class="line">  ca: <span class="literal">null</span>,</span><br><span class="line">  ciphers: [],</span><br><span class="line">  rejectUnauthorized: <span class="literal">true</span>,</span><br><span class="line">  perMessageDeflate: <span class="literal">true</span>,</span><br><span class="line">  forceNode: <span class="literal">false</span>,</span><br><span class="line">  localAddress: <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// options for Node.js / React Native</span></span><br><span class="line">  extraHeaders: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="From-a-different-domain"><a href="#From-a-different-domain" class="headerlink" title="From a different domain"></a>From a different domain</h2><p>In case your front is not served from the same domain as your server, you have to pass the URL of your server.</p>
<p>如果您的前台与服务器不在同一个域中，则必须传递服务器的URL。</p>
<h2 id="Custom-namespace"><a href="#Custom-namespace" class="headerlink" title="Custom namespace"></a>Custom namespace</h2><p>In the examples above, the client will connect to the default namespace. Using only the default namespace should be sufficient for most use cases, but you can specify the namespace with:</p>
<p>在上面的示例中，客户端将连接到默认名称空间。 在大多数情况下，仅使用默认名称空间就足够了，但是您可以通过以下方式指定名称空间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// same origin version</span></span><br><span class="line"><span class="keyword">const</span> socket = io(<span class="string">'/admin'</span>);</span><br><span class="line"><span class="comment">// cross origin version</span></span><br><span class="line"><span class="keyword">const</span> socket = io(<span class="string">'https://server-domain.com/admin'</span>);</span><br></pre></td></tr></table></figure>

<p>You can find more details about namespaces <a href="https://socket.io/docs/namespaces/" target="_blank" rel="noopener">here</a>.</p>
<h2 id="Notable-options"><a href="#Notable-options" class="headerlink" title="Notable options"></a>Notable options</h2><h3 id="transports-option"><a href="#transports-option" class="headerlink" title="transports option"></a><code>transports</code> option</h3><p>By default, the client will try to establish a WebSocket connection, and fall back to XHR/JSONP polling.</p>
<p>If you are sure the WebSocket connection will succeed, you can disable the polling transport:</p>
<p>默认情况下，客户端将尝试建立WebSocket连接，并回退到XHR / JSONP轮询。</p>
<p>如果确定WebSocket连接将成功，则可以禁用轮询传输：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(&#123;</span><br><span class="line">  transports: [<span class="string">'websocket'</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>In that case, due to the nature of the WebSocket connection, you can have several server instances without sticky sessions. More information <a href="https://socket.io/docs/using-multiple-nodes/" target="_blank" rel="noopener">here</a>.</p>
<p>在这种情况下，由于WebSocket连接的性质，您可以有多个服务器实例而没有粘性会话。 更多信息在这里。</p>
<p>Caught a mistake? Edit this page on <a href="https://github.com/socketio/socket.io-website/blob/master/source/docs/client-initialization.md" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/Socket.io/client/2.%20Initialization/" data-id="ckejc3t6l0004vcxngbkp7f2i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Socket.io/server/5. Using multiple nodes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/Socket.io/server/5.%20Using%20multiple%20nodes/" class="article-date">
  <time datetime="2020-08-30T07:46:37.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/Socket.io/server/5.%20Using%20multiple%20nodes/">Using multiple nodes</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Sticky-load-balancing（粘性负载平衡）"><a href="#Sticky-load-balancing（粘性负载平衡）" class="headerlink" title="Sticky load balancing（粘性负载平衡）"></a>Sticky load balancing（粘性负载平衡）</h2><p>If you plan to distribute the load of connections among different processes or machines, you have to make sure that requests associated with a particular session id connect to the process that originated them.</p>
<p>This is due to certain transports like XHR Polling or JSONP Polling relying on firing several requests during the lifetime of the “socket”. Failing to enable sticky balancing will result in the dreaded:</p>
<p>如果计划在不同的进程或机器之间分配连接负载，则必须确保与特定会话ID关联的请求连接到发起它们的进程。</p>
<p>这是由于某些传输（例如XHR轮询或JSONP轮询）在“套接字”的生存期内依赖于触发多个请求而导致的。 无法启用粘性平衡将导致可怕的后果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error during WebSocket handshake: Unexpected response code: 400</span><br></pre></td></tr></table></figure>

<p>Which means that the upgrade request was sent to a node which did not know the given socket id, hence the HTTP 400 response.</p>
<p>To illustrate why this is needed, consider the example of emitting an event to all connected clients:</p>
<p>这意味着升级请求已发送到不知道给定套接字ID的节点，因此不知道HTTP 400响应。</p>
<p>为了说明为什么需要这样做，请考虑向所有连接的客户端发出事件的示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.emit('hi', 'all sockets');</span><br></pre></td></tr></table></figure>

<p>Chances are that some of those clients might have an active bi-directional communication channel like <code>WebSocket</code> that we can write to immediately, but some of them might be using long-polling.</p>
<p>If they’re using long polling, they might or might not have sent a request that we can write to. They could be “in between” those requests. In those situations, it means we have to buffer messages in the process. In order for the client to successfully claim those messages when he sends his request, the easiest way is for him to connect to be routed to that same process.</p>
<p>As noted above, <code>WebSocket</code> transport do not have this limitation, since the underlying TCP connection is kept open between the client and the given server. That’s why you might find some suggestions to only use the <code>WebSocket</code> transport:</p>
<p>可能其中一些客户端可能具有活动的双向通信通道，例如WebSocket，我们可以立即写入该通道，但是其中一些客户端可能正在使用长轮询。</p>
<p>如果他们使用长时间轮询，那么他们可能已经发送或未发送我们可以写入的请求。 它们可能在这些请求之间。 在这种情况下，这意味着我们必须在流程中缓冲消息。 为了使客户端在发送请求时成功声明这些消息，最简单的方法是将其连接到同一进程。</p>
<p>如上所述，WebSocket传输没有此限制，因为底层TCP连接在客户端和给定服务器之间保持打开状态。 因此，您可能会发现一些建议仅使用WebSocket传输：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> client = io(<span class="string">'https://io.yourhost.com'</span>, &#123;</span><br><span class="line">  <span class="comment">// WARNING: in that case, there is no fallback to long-polling</span></span><br><span class="line">  transports: [ <span class="string">'websocket'</span> ] <span class="comment">// or [ 'websocket', 'polling' ], which is the same thing</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Both means that there is <strong>NO FALLBACK</strong> to long-polling when the websocket connection cannot be established, which is in fact one of the key feature of Socket.IO. In that case, you should maybe consider using raw <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank" rel="noopener">WebSocket</a>, or a thin wrapper like <a href="https://github.com/appuri/robust-websocket" target="_blank" rel="noopener">robust-websocket</a>.</p>
<p>To achieve sticky-session, there are two main solutions:</p>
<ul>
<li>routing clients based on their originating address</li>
<li>routing clients based on a cookie</li>
</ul>
<p>两者都意味着当无法建立Websocket连接时，不会回退到长轮询，这实际上是Socket.IO的关键功能之一。 在这种情况下，您可能应该考虑使用原始WebSocket或像robust-websocket这样的薄包装器。</p>
<p>为了实现粘性会话，有两种主要解决方案：</p>
<ul>
<li><p>根据客户端的原始地址路由</p>
</li>
<li><p>根据Cookie路由客户端</p>
</li>
</ul>
<h2 id="NginX-configuration"><a href="#NginX-configuration" class="headerlink" title="NginX configuration"></a>NginX configuration</h2><p>Within the <code>http { }</code> section of your <code>nginx.conf</code> file, you can declare a <code>upstream</code> section with a list of Socket.IO process you want to balance load between:</p>
<p>在nginx.conf文件的http {}部分中，可以声明一个上游部分，其中包含要平衡负载的Socket.IO进程列表：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 3000;</span><br><span class="line">    server_name io.yourhost.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">      proxy_set_header Host $host;</span><br><span class="line"></span><br><span class="line">      proxy_pass http://nodes;</span><br><span class="line"></span><br><span class="line">      # enable WebSockets</span><br><span class="line">      proxy_http_version 1.1;</span><br><span class="line">      proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">      proxy_set_header Connection "upgrade";</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  upstream nodes &#123;</span><br><span class="line">    # enable sticky session based on IP</span><br><span class="line">    ip_hash;</span><br><span class="line"></span><br><span class="line">    server app01:3000;</span><br><span class="line">    server app02:3000;</span><br><span class="line">    server app03:3000;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice the <code>ip_hash</code> instruction that indicates the connections will be sticky.</p>
<p>Make sure you also configure <code>worker_processes</code> in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the <code>worker_connections</code> setting within the <code>events { }</code> block.</p>
<p><a href="https://github.com/socketio/socket.io/tree/master/examples/cluster-nginx" target="_blank" rel="noopener">Example</a></p>
<p>请注意ip_hash指令，该指令指示连接将处于粘性状态。</p>
<p>确保您还在最顶层配置了worker_processes，以指示NginX应该使用多少个worker。 您可能还想研究一下在事件{}块中对worker_connections设置的调整。</p>
<h2 id="Apache-HTTPD-configuration"><a href="#Apache-HTTPD-configuration" class="headerlink" title="Apache HTTPD configuration"></a>Apache HTTPD configuration</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Header add Set-Cookie "SERVERID=sticky.%&#123;BALANCER_WORKER_ROUTE&#125;e; path=/" env=BALANCER_ROUTE_CHANGED</span><br><span class="line"></span><br><span class="line">&lt;Proxy "balancer://nodes_polling"&gt;</span><br><span class="line">    BalancerMember "http://app01:3000" route=app01</span><br><span class="line">    BalancerMember "http://app02:3000" route=app02</span><br><span class="line">    BalancerMember "http://app03:3000" route=app03</span><br><span class="line">    ProxySet stickysession=SERVERID</span><br><span class="line">&lt;/Proxy&gt;</span><br><span class="line"></span><br><span class="line">&lt;Proxy "balancer://nodes_ws"&gt;</span><br><span class="line">    BalancerMember "ws://app01:3000" route=app01</span><br><span class="line">    BalancerMember "ws://app02:3000" route=app02</span><br><span class="line">    BalancerMember "ws://app03:3000" route=app03</span><br><span class="line">    ProxySet stickysession=SERVERID</span><br><span class="line">&lt;/Proxy&gt;</span><br><span class="line"></span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteCond %&#123;HTTP:Upgrade&#125; =websocket [NC]</span><br><span class="line">RewriteRule /(.*) balancer://nodes_ws/$1 [P,L]</span><br><span class="line">RewriteCond %&#123;HTTP:Upgrade&#125; !=websocket [NC]</span><br><span class="line">RewriteRule /(.*) balancer://nodes_polling/$1 [P,L]</span><br><span class="line"></span><br><span class="line">ProxyTimeout 3</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/socketio/socket.io/tree/master/examples/cluster-httpd" target="_blank" rel="noopener">Example</a></p>
<h2 id="HAProxy-configuration"><a href="#HAProxy-configuration" class="headerlink" title="HAProxy configuration"></a>HAProxy configuration</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/</span></span><br><span class="line"></span><br><span class="line">listen chat</span><br><span class="line">  bind *:80</span><br><span class="line">  default_backend nodes</span><br><span class="line"></span><br><span class="line">backend nodes</span><br><span class="line">  option httpchk HEAD /health</span><br><span class="line">  http-check expect status 200</span><br><span class="line">  cookie io prefix indirect nocache # using the `io` cookie set upon handshake</span><br><span class="line">  server app01 app01:3000 check cookie app01</span><br><span class="line">  server app02 app02:3000 check cookie app02</span><br><span class="line">  server app03 app03:3000 check cookie app03</span><br></pre></td></tr></table></figure>

<h2 id="Using-Node-JS-Cluster（使用Node-JS集群）"><a href="#Using-Node-JS-Cluster（使用Node-JS集群）" class="headerlink" title="Using Node.JS Cluster（使用Node.JS集群）"></a>Using Node.JS Cluster（使用Node.JS集群）</h2><p>Just like NginX, Node.JS comes with built-in clustering support through the <code>cluster</code> module.</p>
<p>Fedor Indutny has created a module called <a href="https://github.com/indutny/sticky-session" target="_blank" rel="noopener">sticky session</a> that ensures file descriptors (ie: connections) are routed based on the originating <code>remoteAddress</code> (ie: IP). Please note that this might lead to unbalanced routing, depending on the hashing method.</p>
<p>You could also assign a different port to each worker of the cluster, based on the cluster worker ID, and balance the load with the configuration that you can find above.</p>
<p>就像NginX一样，Node.JS通过集群模块提供了内置的集群支持。</p>
<p>Fedor Indutny创建了一个名为“粘性会话”的模块，该模块可确保文件描述符（即：连接）基于始发的remoteAddress（即：IP）进行路由。 请注意，这可能会导致路由不平衡，具体取决于哈希方法。</p>
<p>您还可以根据集群工作程序ID为集群的每个工作程序分配不同的端口，并通过上面的配置平衡负载。</p>
<h2 id="Passing-events-between-nodes（在节点之间传递事件）"><a href="#Passing-events-between-nodes（在节点之间传递事件）" class="headerlink" title="Passing events between nodes（在节点之间传递事件）"></a>Passing events between nodes（在节点之间传递事件）</h2><p>Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to everyone (or even everyone in a certain <a href="https://socket.io/docs/rooms-and-namespaces/#Rooms" target="_blank" rel="noopener">room</a>) you’ll need some way of passing messages between processes or computers.</p>
<p>The interface in charge of routing messages is what we call the <code>Adapter</code>. You can implement your own on top of the <a href="https://github.com/socketio/socket.io-adapter" target="_blank" rel="noopener">socket.io-adapter</a> (by inheriting from it) or you can use the one we provide on top of <a href="https://redis.io/" target="_blank" rel="noopener">Redis</a>: <a href="https://github.com/socketio/socket.io-redis" target="_blank" rel="noopener">socket.io-redis</a>:</p>
<p>现在，您已经拥有多个接受连接的Socket.IO节点，如果您想向所有人（甚至是某个房间中的所有人）广播事件，您将需要某种方式在进程或计算机之间传递消息。</p>
<p>负责路由消息的接口就是我们所说的适配器。 您可以在socket.io-adapter上实现自己的继承（通过继承），也可以使用我们在Redis之上提供的实现：socket.io-redis：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">'socket.io-redis'</span>);</span><br><span class="line">io.adapter(redis(&#123; <span class="attr">host</span>: <span class="string">'localhost'</span>, <span class="attr">port</span>: <span class="number">6379</span> &#125;));</span><br></pre></td></tr></table></figure>

<p>Then the following call:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.emit(<span class="string">'hi'</span>, <span class="string">'all sockets'</span>);</span><br></pre></td></tr></table></figure>

<p>will be broadcast to every node through the <a href="https://redis.io/topics/pubsub" target="_blank" rel="noopener">Pub/Sub mechanism</a> of Redis.</p>
<p><strong>Note:</strong> sticky-session is still needed when using the Redis adapter.</p>
<p>If you want to pass messages to it from non-socket.io processes, you should look into <a href="https://socket.io/docs/rooms-and-namespaces/#Sending-messages-from-the-outside-world" target="_blank" rel="noopener">“Sending messages from the outside-world”</a>.</p>
<p>将通过Redis的发布/订阅机制广播到每个节点。</p>
<p>注意：使用Redis适配器时仍然需要粘性会话。</p>
<p>如果要从non-socket.io进程向其传递消息，则应查看“从外界发送消息”。</p>
<p>Caught a mistake? Edit this page on <a href="https://github.com/socketio/socket.io-website/blob/master/source/docs/using-multiple-nodes.md" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/Socket.io/server/5.%20Using%20multiple%20nodes/" data-id="ckejc3t6t000bvcxn8pipeqfy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Socket.io/Documentation/1. Introduction" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/Socket.io/Documentation/1.%20Introduction/" class="article-date">
  <time datetime="2020-08-30T07:46:37.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/Socket.io/Documentation/1.%20Introduction/">Introduction</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="What-Socket-IO-is"><a href="#What-Socket-IO-is" class="headerlink" title="What Socket.IO is"></a>What Socket.IO is</h2><p>Socket.IO is a library that enables real-time, bidirectional and event-based communication between the browser and the server. It consists of:</p>
<ul>
<li>a Node.js server: <a href="https://github.com/socketio/socket.io" target="_blank" rel="noopener">Source</a> | <a href="https://socket.io/docs/server-api/" target="_blank" rel="noopener">API</a></li>
<li>a Javascript client library for the browser (which can be also run from Node.js): <a href="https://github.com/socketio/socket.io-client" target="_blank" rel="noopener">Source</a> | <a href="https://socket.io/docs/client-api/" target="_blank" rel="noopener">API</a></li>
</ul>
<p><img src="https://socket.io/images/bidirectional-communication.png" alt="Diagram for bidirectional communication"></p>
<p>There are also several client implementation in other languages, which are maintained by the community:</p>
<ul>
<li>Java: <a href="https://github.com/socketio/socket.io-client-java" target="_blank" rel="noopener">https://github.com/socketio/socket.io-client-java</a></li>
<li>C++: <a href="https://github.com/socketio/socket.io-client-cpp" target="_blank" rel="noopener">https://github.com/socketio/socket.io-client-cpp</a></li>
<li>Swift: <a href="https://github.com/socketio/socket.io-client-swift" target="_blank" rel="noopener">https://github.com/socketio/socket.io-client-swift</a></li>
<li>Dart: <a href="https://github.com/rikulo/socket.io-client-dart" target="_blank" rel="noopener">https://github.com/rikulo/socket.io-client-dart</a></li>
<li>Python: <a href="https://github.com/miguelgrinberg/python-socketio" target="_blank" rel="noopener">https://github.com/miguelgrinberg/python-socketio</a></li>
<li>.Net: <a href="https://github.com/Quobject/SocketIoClientDotNet" target="_blank" rel="noopener">https://github.com/Quobject/SocketIoClientDotNet</a></li>
</ul>
<p>Socket.IO是一个库，可用于在客户端和服务器之间进行实时，双向和基于事件的通信。它包括：</p>
<p>Node.js服务器： API<br>浏览器环境下运行的Javascript客户端（也可以从Node.js运行）： API</p>
<p>还有一些其他语言的客户端实现，由社区维护：</p>
<ul>
<li>Java：https：//github.com/socketio/socket.io-client-java</li>
<li>C ++：https：//github.com/socketio/socket.io-client-cpp</li>
<li>斯威夫特：<a href="https://github.com/socketio/socket.io-client-swift" target="_blank" rel="noopener">https://github.com/socketio/socket.io-client-swift</a></li>
<li>飞镖：https：//github.com/rikulo/socket.io-client-dart</li>
<li>Python：https：//github.com/miguelgrinberg/python-socketio</li>
<li>.Net：https：//github.com/Quobject/SocketIoClientDotNet</li>
</ul>
<h3 id="How-does-that-work"><a href="#How-does-that-work" class="headerlink" title="How does that work?"></a>How does that work?</h3><p>The client will try to establish a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" target="_blank" rel="noopener">WebSocket</a> connection if possible, and will fall back on HTTP long polling if not.</p>
<p>WebSocket is a communication protocol which provides a full-duplex and low-latency channel between the server and the browser. More information can be found <a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">here</a>.</p>
<p>So, in the best-case scenario, provided that:</p>
<ul>
<li>the browser supports WebSocket (<a href="https://caniuse.com/#search=websocket" target="_blank" rel="noopener">97%</a> of all browsers in 2020)</li>
<li>there is no element (proxy, firewall, …) preventing WebSocket connections between the client and the server</li>
</ul>
<p>you can consider the Socket.IO client as a “slight” wrapper around the WebSocket API. Instead of writing:</p>
<p>如果可能，客户端将尝试建立WebSocket连接，如果没有，客户端将使用HTTP长轮询。</p>
<p>WebSocket是一种通信协议，可在服务器和浏览器之间提供全双工和低延迟通道。更多信息可以在这里找到。</p>
<p>因此，在最佳情况下，应提供：</p>
<ul>
<li><p>浏览器支持WebSocket（2020年所有浏览器中的97％）</p>
</li>
<li><p>没有任何元素（代理，防火墙等）阻止客户端和服务器之间的WebSocket连接</p>
</li>
</ul>
<p>您可以将Socket.IO客户端视为WebSocket API的“轻量”包装器。而不是写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000'</span>);</span><br><span class="line"></span><br><span class="line">socket.onopen(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  socket.send(<span class="string">'Hello!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.onmessage(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>You will have, on the client-side:</p>
<p>在客户端，您将拥有：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(<span class="string">'ws://localhost:3000'</span>);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'connect'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// either with send()</span></span><br><span class="line">  socket.send(<span class="string">'Hello!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// or with emit() and custom event names</span></span><br><span class="line">  socket.emit(<span class="string">'salutations'</span>, <span class="string">'Hello!'</span>, &#123; <span class="string">'mr'</span>: <span class="string">'john'</span> &#125;, <span class="built_in">Uint8Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle the event sent with socket.send()</span></span><br><span class="line">socket.on(<span class="string">'message'</span>, data =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle the event sent with socket.emit()</span></span><br><span class="line">socket.on(<span class="string">'greetings'</span>, (elem1, elem2, elem3) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem1, elem2, elem3);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>The API on the server-side is similar, you also get an <code>socket</code> object which extends the Node.js <a href="https://nodejs.org/docs/latest/api/events.html#events_class_eventemitter" target="_blank" rel="noopener">EventEmitter</a> class:</p>
<p>服务器端的API与此类似，您还获得了一个扩展Node.js EventEmitter类的套接字对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connect'</span>, socket =&gt; &#123;</span><br><span class="line">  <span class="comment">// either with send()</span></span><br><span class="line">  socket.send(<span class="string">'Hello!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// or with emit() and custom event names</span></span><br><span class="line">  socket.emit(<span class="string">'greetings'</span>, <span class="string">'Hey!'</span>, &#123; <span class="string">'ms'</span>: <span class="string">'jane'</span> &#125;, Buffer.from([<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// handle the event sent with socket.send()</span></span><br><span class="line">  socket.on(<span class="string">'message'</span>, (data) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// handle the event sent with socket.emit()</span></span><br><span class="line">  socket.on(<span class="string">'salutations'</span>, (elem1, elem2, elem3) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(elem1, elem2, elem3);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Socket.IO provides additional features over a plain WebSocket object, which are listed <a href="https://socket.io/docs/#Features" target="_blank" rel="noopener">below</a>.</p>
<p>But first, let’s detail what the Socket.IO library is not.</p>
<p>Socket.IO在纯WebSocket对象上提供了其他功能，下面列出了这些功能。</p>
<p>但首先，让我们详细说明Socket.IO库不是什么。</p>
<h2 id="What-Socket-IO-is-not"><a href="#What-Socket-IO-is-not" class="headerlink" title="What Socket.IO is not"></a>What Socket.IO is not</h2><p>Socket.IO is <strong>NOT</strong> a WebSocket implementation. Although Socket.IO indeed uses WebSocket as a transport when possible, it adds additional metadata to each packet. That is why a WebSocket client will not be able to successfully connect to a Socket.IO server, and a Socket.IO client will not be able to connect to a plain WebSocket server either.</p>
<p>Socket.IO不是WebSocket实现。 尽管Socket.IO确实确实在可能的情况下使用WebSocket作为传输方式，但它向每个数据包添加了其他元数据。 这就是为什么WebSocket客户端将无法成功连接到Socket.IO服务器，而Socket.IO客户端也将无法连接到普通WebSocket服务器的原因。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WARNING: the client will NOT be able to connect!</span></span><br><span class="line"><span class="keyword">const</span> socket = io(<span class="string">'ws://echo.websocket.org'</span>);</span><br></pre></td></tr></table></figure>

<p>If you are looking for a plain WebSocket server, please take a look at <a href="https://github.com/websockets/ws" target="_blank" rel="noopener">ws</a> or <a href="https://github.com/uNetworking/uWebSockets.js" target="_blank" rel="noopener">uWebSockets.js</a>.</p>
<p>There are also <a href="https://github.com/nodejs/node/issues/19308" target="_blank" rel="noopener">talks</a> to include a WebSocket server in the Node.js core.</p>
<p>On the client-side, you might be interested by the <a href="https://github.com/nathanboktae/robust-websocket" target="_blank" rel="noopener">robust-websocket</a> package.</p>
<p>如果您正在寻找普通的WebSocket服务器，请查看ws或uWebSockets.js。</p>
<p>也有讨论将WebSocket服务器包含在Node.js核心中。</p>
<p>在客户端，您可能会对robust-websocket软件包感兴趣。</p>
<h2 id="Minimal-working-example"><a href="#Minimal-working-example" class="headerlink" title="Minimal working example"></a>Minimal working example</h2><p>If you are new to the Node.js ecosystem, please take a look at the <a href="https://socket.io/get-started/chat" target="_blank" rel="noopener">Get Started</a> guide, which is ideal for beginners.</p>
<p>Else, let’s start right away! The server library can be installed from NPM:</p>
<p>如果您不熟悉Node.js生态系统，请查看《入门指南》，它是初学者的理想选择。</p>
<p>否则，我们马上开始！ 可以从NPM安装服务器库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install socket.io</span><br></pre></td></tr></table></figure>

<p>More information about the installation can be found in the <a href="https://socket.io/docs/server-installation/" target="_blank" rel="noopener">Server installation</a> page.</p>
<p>Then, let’s create an <code>index.js</code> file, with the following content:</p>
<p>有关安装的更多信息，请参见“服务器安装”页面。</p>
<p>然后，我们创建一个index.js文件，其内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> content = <span class="built_in">require</span>(<span class="string">'fs'</span>).readFileSync(__dirname + <span class="string">'/index.html'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpServer = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// serve the index.html file</span></span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>);</span><br><span class="line">  res.setHeader(<span class="string">'Content-Length'</span>, Buffer.byteLength(content));</span><br><span class="line">  res.end(content);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(httpServer);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connect'</span>, socket =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'connect'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">httpServer.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'go to http://localhost:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Here, a classic Node.js <a href="https://nodejs.org/docs/latest/api/http.html#http_class_http_server" target="_blank" rel="noopener">HTTP server</a> is started to serve the <code>index.html</code> file, and the Socket.IO server is attached to it. Please see the <a href="https://socket.io/docs/server-initialization/" target="_blank" rel="noopener">Server initialization</a> page for the various ways to create a server.</p>
<p>Let’s create the <code>index.html</code> file next to it:</p>
<p>在这里，启动了经典的Node.js HTTP服务器来提供index.html文件，并将Socket.IO服务器连接到该服务器。 有关创建服务器的各种方法，请参见服务器初始化页面。</p>
<p>让我们在它旁边创建index.html文件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Minimal working example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"events"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> $events = <span class="built_in">document</span>.getElementById(<span class="string">'events'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> newItem = <span class="function">(<span class="params">content</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> item = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span></span><br><span class="line">          item.innerText = content;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> item;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> socket = io();</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        socket.on(<span class="string">'connect'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">          $events.appendChild(newItem(<span class="string">'connect'</span>));</span></span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Finally, let’s start our server:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure>

<p>![image-20200830095840462](/Users/liyuanmeng/Library/Application Support/typora-user-images/image-20200830095840462.png)</p>
<p>The <code>socket</code> object on both sides extends the EventEmitter class, so:</p>
<ul>
<li>sending an event is done with: <code>socket.emit()</code></li>
<li>receiving an event is done by registering a listener: <code>socket.on(, )</code></li>
</ul>
<p>两侧的套接字对象都扩展了EventEmitter类，因此：</p>
<p>发送事件的方法是：socket.emit（）<br>接收事件是通过注册侦听器完成的：socket.on（&lt;事件名称&gt;，&lt;监听器&gt;）</p>
<h3 id="To-send-an-event-from-the-server-to-the-client"><a href="#To-send-an-event-from-the-server-to-the-client" class="headerlink" title="To send an event from the server to the client"></a>To send an event from the server to the client</h3><p>Let’s update the <code>index.js</code> file (server-side):</p>
<p>让我们更新index.js文件（服务器端）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connect'</span>, socket =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    socket.emit(<span class="string">'hello'</span>, ++counter);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>And the <code>index.html</code> file (client-side):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io();</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'connect'</span>, () =&gt; &#123;</span><br><span class="line">  $events.appendChild(newItem(<span class="string">'connect'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'hello'</span>, (counter) =&gt; &#123;</span><br><span class="line">  $events.appendChild(newItem(<span class="string">`hello - <span class="subst">$&#123;counter&#125;</span>`</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>![image-20200830100611650](/Users/liyuanmeng/Library/Application Support/typora-user-images/image-20200830100611650.png)</p>
<h3 id="To-send-a-message-from-the-client-to-the-server"><a href="#To-send-a-message-from-the-client-to-the-server" class="headerlink" title="To send a message from the client to the server"></a>To send a message from the client to the server</h3><p>Let’s update the <code>index.js</code> file (server-side):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connect'</span>, socket =&gt; &#123;</span><br><span class="line">  socket.on(<span class="string">'hey'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hey'</span>, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>And the <code>index.html</code> file (client-side):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io();</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'connect'</span>, () =&gt; &#123;</span><br><span class="line">  $events.appendChild(newItem(<span class="string">'connect'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ++counter;</span><br><span class="line">  socket.emit(<span class="string">'hey'</span>, &#123; counter &#125;); <span class="comment">// the object will be serialized for you</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>![image-20200830101114485](/Users/liyuanmeng/Library/Application Support/typora-user-images/image-20200830101114485.png)</p>
<p>Now, let’s detail the features provided by Socket.IO.</p>
<p>现在，让我们详细介绍Socket.IO提供的功能。</p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><p>Its main features are:</p>
<h3 id="Reliability（可靠性）"><a href="#Reliability（可靠性）" class="headerlink" title="Reliability（可靠性）"></a>Reliability（可靠性）</h3><p>Connections are established even in the presence of:</p>
<ul>
<li>proxies and load balancers.</li>
<li>personal firewall and antivirus software.</li>
</ul>
<p>For this purpose, it relies on <a href="https://github.com/socketio/engine.io" target="_blank" rel="noopener">Engine.IO</a>, which first establishes a long-polling connection, then tries to upgrade to better transports that are “tested” on the side, like WebSocket. Please see the <a href="https://github.com/socketio/engine.io#goals" target="_blank" rel="noopener">Goals</a> section for more information.</p>
<p>即使存在以下情况也会建立连接：</p>
<ul>
<li>代理和负载均衡。</li>
<li>个人防火墙和防病毒软件。</li>
</ul>
<p>为此，它依赖Engine.IO，该引擎首先建立长轮询连接，然后尝试升级到在侧面进行“测试”的更好传输，例如WebSocket。 请参阅“目标”部分以获取更多信息。</p>
<h3 id="Auto-reconnection-support（自动重新连接支持）"><a href="#Auto-reconnection-support（自动重新连接支持）" class="headerlink" title="Auto-reconnection support（自动重新连接支持）"></a>Auto-reconnection support（自动重新连接支持）</h3><p>Unless instructed otherwise a disconnected client will try to reconnect forever, until the server is available again. Please see the available reconnection options <a href="https://socket.io/docs/client-api/#new-Manager-url-options" target="_blank" rel="noopener">here</a>.</p>
<p>除非另有指示，否则断开连接的客户端将尝试永久重新连接，直到服务器再次可用为止。 请在此处查看可用的重新连接选项。</p>
<h3 id="Disconnection-detection（断线检测）"><a href="#Disconnection-detection（断线检测）" class="headerlink" title="Disconnection detection（断线检测）"></a>Disconnection detection（断线检测）</h3><p>A heartbeat mechanism is implemented at the Engine.IO level, allowing both the server and the client to know when the other one is not responding anymore.</p>
<p>That functionality is achieved with timers set on both the server and the client, with timeout values (the pingInterval and pingTimeout parameters) shared during the connection handshake. Those timers require any subsequent client calls to be directed to the same server, hence the sticky-session requirement when using multiples nodes.</p>
<p>心跳机制在Engine.IO级别上实现，使服务器和客户端都可以知道另一方何时不再响应。</p>
<p>通过在服务器和客户端上设置计时器，并在连接握手期间共享超时值（pingInterval和pingTimeout参数），可以实现该功能。 这些计时器要求将任何后续客户端调用都定向到同一服务器，因此使用多个节点时需要执行粘性会话。</p>
<h3 id="Binary-support（二进制支持）"><a href="#Binary-support（二进制支持）" class="headerlink" title="Binary support（二进制支持）"></a>Binary support（二进制支持）</h3><p>Any serializable data structures can be emitted, including:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a> in the browser</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a> and <a href="https://nodejs.org/api/buffer.html" target="_blank" rel="noopener">Buffer</a> in Node.js</li>
</ul>
<p>可以发出任何可序列化的数据结构，包括：</p>
<ul>
<li><p>浏览器中的ArrayBuffer和Blob</p>
</li>
<li><p>Node.js中的ArrayBuffer和Buffer</p>
</li>
</ul>
<h3 id="Multiplexing-support（多路传输支持）"><a href="#Multiplexing-support（多路传输支持）" class="headerlink" title="Multiplexing support（多路传输支持）"></a>Multiplexing support（多路传输支持）</h3><p>In order to create separation of concerns within your application (for example per module, or based on permissions), Socket.IO allows you to create several <a href="https://socket.io/docs/rooms-and-namespaces/#Namespaces" target="_blank" rel="noopener">Namespaces</a>, which will act as separate communication channels but will share the same underlying connection.</p>
<p>为了在应用程序内创建关注点分离（例如，每个模块或基于权限），Socket.IO允许您创建多个命名空间，这些命名空间将充当单独的通信通道，但将共享相同的基础连接。</p>
<p>Caught a mistake? Edit this page on <a href="https://github.com/socketio/socket.io-website/blob/master/source/docs/index.md" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/Socket.io/Documentation/1.%20Introduction/" data-id="ckejc3t6p000avcxn60xlgl5p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Socket.io/server/3. Namespaces" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/Socket.io/server/3.%20Namespaces/" class="article-date">
  <time datetime="2020-08-30T07:46:37.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/Socket.io/server/3.%20Namespaces/">Namespaces</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>A Namespace is a communication channel that allows you to split the logic of your application over a single shared connection.</p>
<p>命名空间是一个通信通道，它使您可以在单个共享连接上拆分应用程序的逻辑。</p>
<p><img src="https://socket.io/images/namespaces.png" alt="Namespace diagram"></p>
<p>Possible use cases:</p>
<ul>
<li>you want to create an admin namespace that only authorized users have access to, so the logic related to those users is separated from the rest of the application</li>
</ul>
<p>可能的用例：</p>
<ul>
<li>您想要创建仅授权用户有权访问的管理名称空间，因此与这些用户相关的逻辑与应用程序的其余部分分开</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> adminNamespace = io.of(<span class="string">'/admin'</span>);</span><br><span class="line"></span><br><span class="line">adminNamespace.use(<span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ensure the user has sufficient rights</span></span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">adminNamespace.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">  socket.on(<span class="string">'delete user'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>your application has multiple tenants so you want to dynamically create one namespace per tenant</li>
<li>您的应用程序有多个租户，因此您想为每个租户动态创建一个命名空间</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> workspaces = io.of(<span class="regexp">/^\/\w+$/</span>);</span><br><span class="line"></span><br><span class="line">workspaces.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> workspace = socket.nsp;</span><br><span class="line"></span><br><span class="line">  workspace.emit(<span class="string">'hello'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this middleware will be assigned to each namespace</span></span><br><span class="line">workspaces.use(<span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ensure the user has access to the workspace</span></span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Default-namespace"><a href="#Default-namespace" class="headerlink" title="Default namespace"></a>Default namespace</h2><p>We call the default namespace <code>/</code> and it’s the one Socket.IO clients connect to by default, and the one the server listens to by default.</p>
<p>This namespace is identified by <code>io.sockets</code> or simply <code>io</code>:</p>
<p>我们将默认名称空间称为/，它是一个默认连接的Socket.IO客户端，一个默认情况下服务器监听的名称空间。</p>
<p>该名称空间由io.sockets或仅由io标识：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the following two will emit to all the sockets connected to `/`</span></span><br><span class="line">io.sockets.emit(<span class="string">'hi'</span>, <span class="string">'everyone'</span>);</span><br><span class="line">io.emit(<span class="string">'hi'</span>, <span class="string">'everyone'</span>); <span class="comment">// short form</span></span><br></pre></td></tr></table></figure>

<p>Each namespace emits a <code>connection</code> event that receives each <code>Socket</code> instance as a parameter</p>
<p>每个名称空间都发出一个连接事件，该事件接收每个Socket实例作为参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">  socket.on(<span class="string">'disconnect'</span>, () =&gt; &#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Custom-namespaces"><a href="#Custom-namespaces" class="headerlink" title="Custom namespaces"></a>Custom namespaces</h2><p>To set up a custom namespace, you can call the of function on the server-side:</p>
<p>要设置自定义名称空间，可以在服务器端调用of函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nsp = io.of(<span class="string">'/my-namespace'</span>);</span><br><span class="line"></span><br><span class="line">nsp.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'someone connected'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">nsp.emit(<span class="string">'hi'</span>, <span class="string">'everyone!'</span>);</span><br></pre></td></tr></table></figure>

<p>On the client side, you tell Socket.IO client to connect to that namespace:</p>
<p>在客户端，您告诉Socket.IO客户端连接到该名称空间：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(<span class="string">'/my-namespace'</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Important note:</strong> The namespace is an implementation detail of the Socket.IO protocol, and is not related to the actual URL of the underlying transport, which defaults to <code>/socket.io/…</code>.</p>
<p>重要说明：名称空间是Socket.IO协议的实现细节，并且与基础传输的实际URL不相关，该URL默认为/socket.io/…。</p>
<h2 id="Namespace-middleware（命名空间中间件）"><a href="#Namespace-middleware（命名空间中间件）" class="headerlink" title="Namespace middleware（命名空间中间件）"></a>Namespace middleware（命名空间中间件）</h2><p>A middleware is a function that gets executed for every incoming Socket, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware. A Socket.IO middleware is very similar to what you can find in <a href="http://expressjs.com/en/guide/using-middleware.html" target="_blank" rel="noopener">Express</a>.</p>
<p>中间件是为每个传入的Socket执行的函数，并接收该套接字和参数作为选择将执行推迟到下一个注册的中间件作为参数。 Socket.IO中间件与Express中非常相似。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// registers a middleware for the default namespace</span></span><br><span class="line">io.use(<span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isValid(socket.request)) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'invalid'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// registers a middleware for a custom namespace</span></span><br><span class="line">io.of(<span class="string">'/admin'</span>).use(<span class="keyword">async</span> (socket, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> fetchUser(socket.handshake.query);</span><br><span class="line">  <span class="keyword">if</span> (user.isAdmin) &#123;</span><br><span class="line">    socket.user = user;</span><br><span class="line">    next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'forbidden'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>You can register several middleware functions for the same namespace. They will be executed sequentially:</p>
<p>您可以为同一名称空间注册多个中间件功能。 它们将按顺序执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">io.use(<span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.use(<span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line">  next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'thou shall not pass'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.use(<span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// not executed, since the previous middleware has returned an error</span></span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Handling-middleware-error"><a href="#Handling-middleware-error" class="headerlink" title="Handling middleware error"></a>Handling middleware error</h2><p>If the <code>next</code> method is called with an Error object, the client will receive an <code>error</code> event.</p>
<p>如果使用错误对象调用“下一个”方法，则客户端将收到一个“错误”事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io <span class="keyword">from</span> <span class="string">'socket.io-client'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = io();</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'error'</span>, (reason) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason); <span class="comment">// prints the message associated with the error, e.g. "thou shall not pass" in the example above</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Compatibility-with-Express-middleware（与Express中间件的兼容性）"><a href="#Compatibility-with-Express-middleware（与Express中间件的兼容性）" class="headerlink" title="Compatibility with Express middleware（与Express中间件的兼容性）"></a>Compatibility with Express middleware（与Express中间件的兼容性）</h2><p>Most existing <a href="http://expressjs.com/en/resources/middleware.html" target="_blank" rel="noopener">Express middleware</a> modules should be compatible with Socket.IO, you just need a little wrapper function to make the method signatures match:</p>
<p>大多数现有的Express中间件模块应与Socket.IO兼容，您只需要一个包装函数即可使方法签名匹配：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrap = <span class="function"><span class="params">middleware</span> =&gt;</span> <span class="function">(<span class="params">socket, next</span>) =&gt;</span> middleware(socket.request, &#123;&#125;, next);</span><br></pre></td></tr></table></figure>

<p>The middleware functions that end the request-response cycle and do not call <code>next()</code> will not work though.</p>
<p>Example with <a href="https://www.npmjs.com/package/express-session" target="_blank" rel="noopener">express-session</a>:</p>
<p>但是，终止请求-响应周期并且不调用next（）的中间件函数将无法工作。</p>
<p>快速会话示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"></span><br><span class="line">io.use(wrap(session(&#123; <span class="attr">secret</span>: <span class="string">'cats'</span> &#125;)));</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connect'</span>, (socket) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> session = socket.request.session;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Example with <a href="http://www.passportjs.org/" target="_blank" rel="noopener">Passport</a>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"><span class="keyword">const</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>);</span><br><span class="line"></span><br><span class="line">io.use(wrap(session(&#123; <span class="attr">secret</span>: <span class="string">'cats'</span> &#125;)));</span><br><span class="line">io.use(wrap(passport.initialize()));</span><br><span class="line">io.use(wrap(passport.session()));</span><br><span class="line"></span><br><span class="line">io.use(<span class="function">(<span class="params">socket, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (socket.request.user) &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unauthorized'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>A complete example with Passport can be found <a href="https://github.com/socketio/socket.io/tree/master/examples/passport-example" target="_blank" rel="noopener">here</a>.</p>
<p>Caught a mistake? Edit this page on <a href="https://github.com/socketio/socket.io-website/blob/master/source/docs/namespaces.md" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/Socket.io/server/3.%20Namespaces/" data-id="ckejc3t6o0009vcxnh8pz9f4h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Socket.io/Introduction" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/Socket.io/Introduction/" class="article-date">
  <time datetime="2020-08-30T07:46:37.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/Socket.io/Introduction/">Introduction</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In this guide we’ll create a basic chat application. It requires almost no basic prior knowledge of Node.JS or Socket.IO, so it’s ideal for users of all knowledge levels.</p>
<p>在本指南中，我们将创建一个基本的聊天应用程序。 它几乎不需要Node.JS或Socket.IO的基础知识，因此非常适合所有知识水平的用户。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Writing a chat application with popular web applications stacks like LAMP (PHP) has normally been very hard. It involves polling the server for changes, keeping track of timestamps, and it’s a lot slower than it should be.</p>
<p>Sockets have traditionally been the solution around which most real-time chat systems are architected, providing a bi-directional communication channel between a client and a server.</p>
<p>This means that the server can push messages to clients. Whenever you write a chat message, the idea is that the server will get it and push it to all other connected clients.</p>
<p>使用LAMP（PHP）等流行的Web应用程序堆栈编写聊天应用程序通常非常困难。 它涉及轮询服务器的更改，跟踪时间戳，并且比预期的要慢得多。</p>
<p>传统上，套接字是构建大多数实时聊天系统的解决方案，可在客户端和服务器之间提供双向通信通道。</p>
<p>这意味着服务器可以将消息推送到客户端。 每当您编写聊天消息时，其想法都是服务器将获得该消息并将其推送到所有其他已连接的客户端。</p>
<h2 id="The-web-framework"><a href="#The-web-framework" class="headerlink" title="The web framework"></a>The web framework</h2><p>The first goal is to set up a simple HTML webpage that serves out a form and a list of messages. We’re going to use the Node.JS web framework <code>express</code> to this end. Make sure <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.JS</a> is installed.</p>
<p>First let’s create a <code>package.json</code> manifest file that describes our project. I recommend you place it in a dedicated empty directory (I’ll call mine <code>chat-example</code>).</p>
<p>第一个目标是建立一个简单的HTML网页，以提供表单和消息列表。 为此，我们将使用Node.JS网络框架<code>express</code>。 确保已安装[Node.JS]（<a href="https://nodejs.org/）。" target="_blank" rel="noopener">https://nodejs.org/）。</a></p>
<p>首先，我们创建一个描述我们项目的package.json清单文件。 我建议您将其放在专用的空白目录中（我将其称为“聊天示例”）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"socket-chat-example"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"my first socket.io app"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now, in order to easily populate the <code>dependencies</code> property with the things we need, we’ll use <code>npm install</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express@4.15.2</span><br></pre></td></tr></table></figure>

<p>Once it’s installed we can create an <code>index.js</code> file that will set up our application.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(app);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">'&lt;h1&gt;Hello world&lt;/h1&gt;'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on *:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>This means that it:</p>
<ul>
<li>Express initializes <code>app</code> to be a function handler that you can supply to an HTTP server (as seen in line 2).</li>
<li>We define a route handler <code>/</code> that gets called when we hit our website home.</li>
<li>We make the http server listen on port 3000.</li>
</ul>
<p>If you run <code>node index.js</code> you should see the following:</p>
<p>这意味着：</p>
<ul>
<li>Express将<code>app</code>初始化为可以提供给HTTP服务器的函数处理程序（如第2行所示）。</li>
<li>我们定义了一个路由处理程序<code>/</code>，当我们访问我们的网站首页时会调用它。</li>
<li>我们使http服务器在端口3000上侦听。</li>
</ul>
<p>如果运行<code>node index.js</code>，您将看到以下内容：</p>
<p>![image-20200828144327055](/Users/liyuanmeng/Library/Application Support/typora-user-images/image-20200828144327055.png)</p>
<p>And if you point your browser to <code>http://localhost:3000</code>:</p>
<p>![image-20200828144339554](/Users/liyuanmeng/Library/Application Support/typora-user-images/image-20200828144339554.png)</p>
<h2 id="Serving-HTML"><a href="#Serving-HTML" class="headerlink" title="Serving HTML"></a>Serving HTML</h2><p>So far in index.js we’re calling res.send and passing it a string of HTML. Our code would look very confusing if we just placed our entire application’s HTML there, so instead we’re going to create a index.html file and serve that instead.</p>
<p>Let’s refactor our route handler to use sendFile instead.</p>
<p>到目前为止，在index.js中，我们正在调用res.send并将其传递为HTML字符串。 如果仅将整个应用程序的HTML放在此处，我们的代码就会看起来很混乱，因此，我们将创建一个index.html文件并将其提供。</p>
<p>让我们重构路由处理程序，改为使用sendFile。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get('/', (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(__dirname + '/index.html');</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Put the following in your <code>index.html</code> file:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Socket.IO chat<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      * &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; <span class="attribute">box-sizing</span>: border-box; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">body</span> &#123; <span class="attribute">font</span>: <span class="number">13px</span> Helvetica, Arial; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">form</span> &#123; <span class="attribute">background</span>: <span class="number">#000</span>; <span class="attribute">padding</span>: <span class="number">3px</span>; <span class="attribute">position</span>: fixed; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">form</span> <span class="selector-tag">input</span> &#123; <span class="attribute">border</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="attribute">width</span>: <span class="number">90%</span>; <span class="attribute">margin-right</span>: <span class="number">0.5%</span>; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">form</span> <span class="selector-tag">button</span> &#123; <span class="attribute">width</span>: <span class="number">9%</span>; <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">130</span>, <span class="number">224</span>, <span class="number">255</span>); <span class="attribute">border</span>: none; <span class="attribute">padding</span>: <span class="number">10px</span>; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-id">#messages</span> &#123; <span class="attribute">list-style-type</span>: none; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-id">#messages</span> <span class="selector-tag">li</span> &#123; <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span>; &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-id">#messages</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(odd)</span> &#123; <span class="attribute">background</span>: <span class="number">#eee</span>; &#125;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"messages"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"m"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span> /&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>Send<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>If you restart the process (by hitting Control+C and running <code>node index.js</code> again) and refresh the page it should look like this:</p>
<p>![image-20200828144033697](/Users/liyuanmeng/Library/Application Support/typora-user-images/image-20200828144033697.png)</p>
<h2 id="Integrating-Socket-IO"><a href="#Integrating-Socket-IO" class="headerlink" title="Integrating Socket.IO"></a>Integrating Socket.IO</h2><p>Socket.IO is composed of two parts:</p>
<ul>
<li>A server that integrates with (or mounts on) the Node.JS HTTP Server <a href="https://github.com/socketio/socket.io" target="_blank" rel="noopener">socket.io</a></li>
<li>A client library that loads on the browser side <a href="https://github.com/socketio/socket.io-client" target="_blank" rel="noopener">socket.io-client</a></li>
</ul>
<p>During development, <code>socket.io</code> serves the client automatically for us, as we’ll see, so for now we only have to install one module:</p>
<p>Socket.IO由两部分组成：</p>
<ul>
<li><p>与Node.JS HTTP Server socket.io集成（或挂载）的服务器</p>
</li>
<li><p>在浏览器端加载的客户端库socket.io-client</p>
</li>
</ul>
<p>如我们所见，在开发过程中，socket.io为我们自动为客户端提供服务，因此，现在我们只需要安装一个模块：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install socket.io</span><br></pre></td></tr></table></figure>

<p>That will install the module and add the dependency to <code>package.json</code>. Now let’s edit <code>index.js</code> to add it:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(app);</span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(http);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(__dirname + <span class="string">'/index.html'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a user connected'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on *:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Notice that I initialize a new instance of <code>socket.io</code> by passing the <code>http</code> (the HTTP server) object. Then I listen on the <code>connection</code> event for incoming sockets and log it to the console.</p>
<p>Now in index.html add the following snippet before the `` (end body tag):</p>
<p>请注意，我通过传递http（HTTP服务器）对象来初始化socket.io的新实例。 然后，我侦听传入套接字的连接事件，并将其记录到控制台。</p>
<p>现在在index.html中，在&lt;/ body&gt;（结束body标签）之前添加以下代码段：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> socket = io();</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>That’s all it takes to load the <code>socket.io-client</code>, which exposes an <code>io</code> global (and the endpoint <code>GET /socket.io/socket.io.js</code>), and then connect.</p>
<p>If you would like to use the local version of the client-side JS file, you can find it at <code>node_modules/socket.io-client/dist/socket.io.js</code>.</p>
<p>Notice that I’m not specifying any URL when I call <code>io()</code>, since it defaults to trying to connect to the host that serves the page.</p>
<p>If you now restart the process (by hitting Control+C and running <code>node index.js</code> again) and then refresh the webpage you should see the console print “a user connected”.</p>
<p>Try opening several tabs, and you’ll see several messages.</p>
<p>这就是加载socket.io-client的全部工作，它公开了一个io全局（和端点GET /socket.io/socket.io.js），然后进行连接。</p>
<p>如果要使用客户端JS文件的本地版本，可以在node_modules / socket.io-client / dist / socket.io.js中找到它。</p>
<p>请注意，我在调用io（）时未指定任何URL，因为它默认为尝试连接到为该页面提供服务的主机。</p>
<p>如果现在重新启动该过程（通过单击Control + C并再次运行节点index.js），然后刷新网页，则应该看到控制台打印“用户已连接”。</p>
<p>尝试打开多个标签，您会看到多则消息。</p>
<p>![image-20200828151113781](/Users/liyuanmeng/Library/Application Support/typora-user-images/image-20200828151113781.png)</p>
<p>Each socket also fires a special <code>disconnect</code> event:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a user connected'</span>);</span><br><span class="line">  socket.on(<span class="string">'disconnect'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'user disconnected'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Then if you refresh a tab several times you can see it in action.![image-20200828151141285](/Users/liyuanmeng/Library/Application Support/typora-user-images/image-20200828151141285.png)</p>
<h2 id="Emitting-events"><a href="#Emitting-events" class="headerlink" title="Emitting events"></a>Emitting events</h2><p>The main idea behind Socket.IO is that you can send and receive any events you want, with any data you want. Any objects that can be encoded as JSON will do, and <a href="https://socket.io/blog/introducing-socket-io-1-0/#binary" target="_blank" rel="noopener">binary data</a> is supported too.</p>
<p>Let’s make it so that when the user types in a message, the server gets it as a <code>chat message</code> event. The <code>script</code> section in <code>index.html</code> should now look as follows:</p>
<p>Socket.IO的主要思想是，您可以使用所需的任何数据发送和接收所需的任何事件。 任何可以被编码为JSON的对象都可以，并且也支持二进制数据。</p>
<p>让我们做到这一点，以便用户输入消息时，服务器将其作为聊天消息事件来获取。 现在，index.html中的脚本部分应如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.4.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket = io();</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'form'</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">      e.preventDefault(); <span class="comment">// prevents page reloading</span></span></span><br><span class="line"><span class="javascript">      socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val());</span></span><br><span class="line"><span class="javascript">      $(<span class="string">'#m'</span>).val(<span class="string">''</span>);</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>And in <code>index.js</code> we print out the <code>chat message</code> event:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</span><br><span class="line">  socket.on(<span class="string">'chat message'</span>, (msg) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'message: '</span> + msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>The result should be like the following video:</p>
<p><video autoplay="" loop="" width="100%" style="color: rgb(85, 85, 85); font-family: &quot;Open Sans&quot;, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"></video></p>
<h2 id="Broadcasting"><a href="#Broadcasting" class="headerlink" title="Broadcasting"></a>Broadcasting</h2><p>The next goal is for us to emit the event from the server to the rest of the users.</p>
<p>In order to send an event to everyone, Socket.IO gives us the <code>io.emit()</code> method.</p>
<p>我们的下一个目标是将事件从服务器发送给其他用户。</p>
<p>为了向所有人发送事件，Socket.IO提供了io.emit（）方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io.emit(<span class="string">'some event'</span>, &#123; <span class="attr">someProperty</span>: <span class="string">'some value'</span>, <span class="attr">otherProperty</span>: <span class="string">'other value'</span> &#125;); <span class="comment">// This will emit the event to all connected socket</span></span><br></pre></td></tr></table></figure>

<p>If you want to send a message to everyone except for a certain emitting socket, we have the <code>broadcast</code> flag for emitting from that socket:</p>
<p>如果您想向除某个发射套接字之外的所有人发送消息，我们具有从该套接字发射的广播标志：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</span><br><span class="line">  socket.broadcast.emit(<span class="string">'hi'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>In this case, for the sake of simplicity we’ll send the message to everyone, including the sender.</p>
<p>在这种情况下，为简单起见，我们会将邮件发送给所有人，包括发件人。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.on(<span class="string">'connection'</span>, (socket) =&gt; &#123;</span><br><span class="line">  socket.on(<span class="string">'chat message'</span>, (msg) =&gt; &#123;</span><br><span class="line">    io.emit(<span class="string">'chat message'</span>, msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>And on the client side when we capture a <code>chat message</code> event we’ll include it in the page. The <em>total</em> client-side JavaScript code now amounts to:</p>
<p>在客户端，当我们捕获聊天消息事件时，会将其包括在页面中。 客户端JavaScript代码总数现在达到：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> socket = io();</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'form'</span>).submit(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">      e.preventDefault(); <span class="comment">// prevents page reloading</span></span></span><br><span class="line"><span class="javascript">      socket.emit(<span class="string">'chat message'</span>, $(<span class="string">'#m'</span>).val());</span></span><br><span class="line"><span class="javascript">      $(<span class="string">'#m'</span>).val(<span class="string">''</span>);</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    socket.on(<span class="string">'chat message'</span>, <span class="function"><span class="keyword">function</span><span class="params">(msg)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">      $(<span class="string">'#messages'</span>).append($(<span class="string">'&lt;li&gt;'</span>).text(msg));</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>And that completes our chat application, in about 20 lines of code! This is what it looks like:</p>
<p><video autoplay="" loop="" width="100%"></video></p>
<h2 id="Homework"><a href="#Homework" class="headerlink" title="Homework"></a>Homework</h2><p>Here are some ideas to improve the application:</p>
<ul>
<li>Broadcast a message to connected users when someone connects or disconnects.</li>
<li>Add support for nicknames.</li>
<li>Don’t send the same message to the user that sent it. Instead, append the message directly as soon as he/she presses enter.</li>
<li>Add “{user} is typing” functionality.</li>
<li>Show who’s online.</li>
<li>Add private messaging.</li>
<li>Share your improvements!</li>
</ul>
<p>以下是一些改进应用程序的想法：</p>
<ul>
<li>当有人连接或断开连接时，向连接的用户广播消息。</li>
<li>添加对昵称的支持。</li>
<li>不要将相同的消息发送给发送该消息的用户。 而是，只要他/她按下Enter键，就直接添加消息。</li>
<li>显示谁在线。</li>
<li>添加私人消息。</li>
<li>分享您的改进！</li>
</ul>
<h2 id="Getting-this-example"><a href="#Getting-this-example" class="headerlink" title="Getting this example"></a>Getting this example</h2><p>You can find it on GitHub <a href="https://github.com/socketio/chat-example" target="_blank" rel="noopener">here</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;socketio&#x2F;chat-example.git</span><br></pre></td></tr></table></figure>

<p>Caught a mistake? Edit this page on <a href="https://github.com/socketio/socket.io-website/blob/master/source/get-started/chat.md" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/Socket.io/Introduction/" data-id="ckejc3t6h0000vcxn6goc8hsq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Socket.io/Documentation/3. Logging and debugging" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/Socket.io/Documentation/3.%20Logging%20and%20debugging/" class="article-date">
  <time datetime="2020-08-30T07:46:37.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/Socket.io/Documentation/3.%20Logging%20and%20debugging/">Logging and debugging</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Socket.IO is now completely instrumented by a minimalistic yet tremendously powerful utility called <a href="https://github.com/visionmedia/debug" target="_blank" rel="noopener">debug</a> by TJ Holowaychuk.</p>
<p>Before 1.0, the Socket.IO server would default to logging everything out to the console. This turned out to be annoyingly verbose for many users (although extremely useful for others), so now we default to being completely silent by default.</p>
<p>The basic idea is that each module used by Socket.IO provides different debugging scopes that give you insight into the internals. By default, all output is suppressed, and you can opt into seeing messages by supplying the <code>DEBUG</code> env variable (Node.JS) or the <code>localStorage.debug</code> property (Browsers).</p>
<p>You can see it in action for example on our homepage:</p>
<p>Socket.IO现在完全由TJ Holowaychuk称为debug的简约但功能强大的实用程序完成。</p>
<p>在1.0之前，Socket.IO服务器将默认将所有内容注销到控制台。 事实证明，这对于许多用户来说是非常烦人的（尽管对其他用户而言非常有用），因此现在默认情况下，我们默认为完全静音。</p>
<p>基本思想是Socket.IO使用的每个模块都提供不同的调试作用域，使您可以深入了解内部。 默认情况下，所有输出都是禁止的，您可以通过提供DEBUG env变量（Node.JS）或localStorage.debug属性（浏览器）来选择查看消息。</p>
<p>您可以在我们的主页上看到它的实际运行情况：</p>
<h2 id="Available-debugging-scopes"><a href="#Available-debugging-scopes" class="headerlink" title="Available debugging scopes"></a>Available debugging scopes</h2><p>The best way to see what information is available is to use the <code>*</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG=* node yourfile.js</span><br></pre></td></tr></table></figure>

<p>or in the browser:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.debug = '*';</span><br></pre></td></tr></table></figure>

<p>And then filter by the scopes you’re interested in. You can prefix the <code>*</code> with scopes, separated by comma if there is more than one. For example, to only see debug statements from the socket.io client on Node.js try this:</p>
<p>然后按感兴趣的范围进行过滤。您可以在*前面加上范围，如果有多个，则以逗号分隔。 例如，要仅查看Node.js上来自socket.io客户端的调试语句，请尝试以下操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG=socket.io:client* node yourfile.js</span><br></pre></td></tr></table></figure>

<p>To see all debug messages from the engine <em>and</em> socket.io:</p>
<p>要查看来自engine和socket.io的所有调试消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG=engine,socket.io* node yourfile.js</span><br></pre></td></tr></table></figure>

<p>Caught a mistake? Edit this page on <a href="https://github.com/socketio/socket.io-website/blob/master/source/docs/logging-and-debugging.md" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/Socket.io/Documentation/3.%20Logging%20and%20debugging/" data-id="ckejc3t6j0001vcxn50a0alue" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Socket.io/Documentation/2. Emit cheatsheet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/Socket.io/Documentation/2.%20Emit%20cheatsheet/" class="article-date">
  <time datetime="2020-08-30T07:46:37.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/Socket.io/Documentation/2.%20Emit%20cheatsheet/">Emit cheatsheet</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">io.on(<span class="string">'connect'</span>, onConnect);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onConnect</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending to the client</span></span><br><span class="line">  socket.emit(<span class="string">'hello'</span>, <span class="string">'can you hear me?'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'abc'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending to all clients except sender</span></span><br><span class="line">  socket.broadcast.emit(<span class="string">'broadcast'</span>, <span class="string">'hello friends!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending to all clients in 'game' room except sender</span></span><br><span class="line">  socket.to(<span class="string">'game'</span>).emit(<span class="string">'nice game'</span>, <span class="string">"let's play a game"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending to all clients in 'game1' and/or in 'game2' room, except sender</span></span><br><span class="line">  socket.to(<span class="string">'game1'</span>).to(<span class="string">'game2'</span>).emit(<span class="string">'nice game'</span>, <span class="string">"let's play a game (too)"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending to all clients in 'game' room, including sender</span></span><br><span class="line">  io.in(<span class="string">'game'</span>).emit(<span class="string">'big-announcement'</span>, <span class="string">'the game will start soon'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending to all clients in namespace 'myNamespace', including sender</span></span><br><span class="line">  io.of(<span class="string">'myNamespace'</span>).emit(<span class="string">'bigger-announcement'</span>, <span class="string">'the tournament will start soon'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending to a specific room in a specific namespace, including sender</span></span><br><span class="line">  io.of(<span class="string">'myNamespace'</span>).to(<span class="string">'room'</span>).emit(<span class="string">'event'</span>, <span class="string">'message'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending to individual socketid (private message)</span></span><br><span class="line">  io.to(socketId).emit(<span class="string">'hey'</span>, <span class="string">'I just met you'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room</span></span><br><span class="line">  <span class="comment">// named `socket.id` but the sender. Please use the classic `socket.emit()` instead.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending with acknowledgement</span></span><br><span class="line">  socket.emit(<span class="string">'question'</span>, <span class="string">'do you think so?'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">answer</span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending without compression</span></span><br><span class="line">  socket.compress(<span class="literal">false</span>).emit(<span class="string">'uncompressed'</span>, <span class="string">"that's rough"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending a message that might be dropped if the client is not ready to receive messages</span></span><br><span class="line">  socket.volatile.emit(<span class="string">'maybe'</span>, <span class="string">'do you really need it?'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// specifying whether the data to send has binary data</span></span><br><span class="line">  socket.binary(<span class="literal">false</span>).emit(<span class="string">'what'</span>, <span class="string">'I have no binaries!'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending to all clients on this node (when using multiple nodes)</span></span><br><span class="line">  io.local.emit(<span class="string">'hi'</span>, <span class="string">'my lovely babies'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sending to all connected clients</span></span><br><span class="line">  io.emit(<span class="string">'an event sent to all connected clients'</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> The following events are reserved and should not be used as event names by your application:</p>
<ul>
<li><code>connect</code></li>
<li><code>connect_error</code></li>
<li><code>connect_timeout</code></li>
<li><code>error</code></li>
<li><code>disconnect</code></li>
<li><code>disconnecting</code></li>
<li><code>newListener</code></li>
<li><code>reconnect_attempt</code></li>
<li><code>reconnecting</code></li>
<li><code>reconnect_error</code></li>
<li><code>reconnect_failed</code></li>
<li><code>removeListener</code></li>
<li><code>ping</code></li>
<li><code>pong</code></li>
</ul>
<p>Caught a mistake? Edit this page on <a href="https://github.com/socketio/socket.io-website/blob/master/source/docs/emit-cheatsheet.md" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/Socket.io/Documentation/2.%20Emit%20cheatsheet/" data-id="ckejc3t6j0002vcxn2r342gas" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Socket.io/client/1. Installation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/Socket.io/client/1.%20Installation/" class="article-date">
  <time datetime="2020-08-30T07:46:37.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/Socket.io/client/1.%20Installation/">Installation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Compatibility（兼容性）"><a href="#Compatibility（兼容性）" class="headerlink" title="Compatibility（兼容性）"></a>Compatibility（兼容性）</h2><p>Socket.IO does support IE9 and above. IE 6/7/8 are not supported anymore.</p>
<p>Browser compatibility is tested thanks to the awesome Sauce Labs platform:</p>
<p>Socket.IO确实支持IE9及更高版本。 不再支持IE 6/7/8。</p>
<p>出色的Sauce Labs平台对浏览器的兼容性进行了测试：</p>
<p><img src="https://socket.io/images/saucelabs.svg" alt="Browser support"></p>
<h2 id="Release-notes"><a href="#Release-notes" class="headerlink" title="Release notes"></a>Release notes</h2><p>The release notes of each version can be found in <a href="https://github.com/socketio/socket.io-client/releases" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><h3 id="Standalone-build（独立构建）"><a href="#Standalone-build（独立构建）" class="headerlink" title="Standalone build（独立构建）"></a>Standalone build（独立构建）</h3><p>By default, the Socket.IO server exposes a client bundle at <code>/socket.io/socket.io.js</code>.</p>
<p><code>io</code> will be registered as a global variable:</p>
<p>默认情况下，Socket.IO服务器在/socket.io/socket.io.js公开客户端捆绑包。</p>
<p>io将被注册为全局变量：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> socket = io();</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>If you don’t need this (see other options below), you can disable the functionality on the server side:</p>
<p>如果不需要此功能（请参见下面的其他选项），则可以在服务器端禁用此功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(&#123;</span><br><span class="line">  serveClient: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="From-a-CDN"><a href="#From-a-CDN" class="headerlink" title="From a CDN"></a>From a CDN</h3><p>You can also include the client bundle from a CDN:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Socket.IO is also available from other CDN like <a href="https://cdn.jsdelivr.net/npm/socket.io-client@2.3.0/dist/socket.io.js" target="_blank" rel="noopener">jsDelivr</a> and <a href="https://unpkg.com/socket.io-client@2.3.0/dist/socket.io.js" target="_blank" rel="noopener">unpkg</a>.</p>
<p>There are several bundles available:</p>
<p>也可以从其他CDN（如jsDelivr和unpkg）获得Socket.IO。</p>
<p>有几种可用的捆绑包：</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Size</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">socket.io.js</td>
<td align="left">19.8 kB min+gzip</td>
<td align="left">Production version, with <a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener">debug</a></td>
</tr>
<tr>
<td align="left">socket.io.slim.js</td>
<td align="left">15.6 kB min+gzip</td>
<td align="left">Production version, without <a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener">debug</a></td>
</tr>
<tr>
<td align="left">socket.io.dev.js</td>
<td align="left">38.5 kB gzip</td>
<td align="left">Unminified version, with <a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener">debug</a></td>
</tr>
</tbody></table>
<p>The <a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener">debug</a> package allows to print debug information to the console. You can find more information <a href="https://socket.io/docs/logging-and-debugging/" target="_blank" rel="noopener">here</a>.</p>
<p>During development, we recommend to use the <code>socket.io.dev.js</code> bundle. By setting <code>localStorage.debug = &#39;socket.io-client:socket&#39;</code>, any event received by the client will be printed to the console.</p>
<p>For production, please use the <code>socket.io.slim.js</code> bundle, which is an optimized build excluding the debug package.</p>
<p>[debug]（<a href="https://www.npmjs.com/package/debug）软件包可将调试信息打印到控制台。" target="_blank" rel="noopener">https://www.npmjs.com/package/debug）软件包可将调试信息打印到控制台。</a> 您可以在[此处]（<a href="https://socket.io/docs/logging-and-debugging/）中找到更多信息。" target="_blank" rel="noopener">https://socket.io/docs/logging-and-debugging/）中找到更多信息。</a></p>
<p>在开发期间，我们建议使用<code>socket.io.dev.js</code>捆绑包。 通过设置<code>localStorage.debug =&#39;socket.io-client：socket&#39;</code>，客户端收到的任何事件都将被打印到控制台。</p>
<p>对于生产，请使用<code>socket.io.slim.js</code>捆绑包，该捆绑包是经过优化的构建，不包括调试包。</p>
<h3 id="From-NPM"><a href="#From-NPM" class="headerlink" title="From NPM"></a>From NPM</h3><p>The Socket.IO client is compatible with bundler like <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> or <a href="http://browserify.org/" target="_blank" rel="noopener">browserify</a>.</p>
<p>Socket.IO客户端与webpack或browserify等捆绑程序兼容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install socket.io-client</span><br></pre></td></tr></table></figure>

<p>The client can also be run from Node.js.</p>
<p>Caught a mistake? Edit this page on <a href="https://github.com/socketio/socket.io-website/blob/master/source/docs/client-installation.md" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/Socket.io/client/1.%20Installation/" data-id="ckejc3t6k0003vcxn0u201bht" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Socket.io/server/1. Installation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/Socket.io/server/1.%20Installation/" class="article-date">
  <time datetime="2020-08-30T07:46:37.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/Socket.io/server/1.%20Installation/">Installation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Prerequisites（先决条件）"><a href="#Prerequisites（先决条件）" class="headerlink" title="Prerequisites（先决条件）"></a>Prerequisites（先决条件）</h2><p>Please make sure that <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> is installed on your system. The current Long Term Support (LTS) release is an ideal starting point.</p>
<p>At least Node.js 8 is needed, older versions are not supported anymore.</p>
<p>请确保您的系统上已安装Node.js。 当前的长期支持（LTS）版本是理想的起点。</p>
<p>至少需要Node.js 8，不再支持旧版本。</p>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>The latest Socket.IO release is:</p>
<p><a href="https://www.npmjs.com/package/socket.io" target="_blank" rel="noopener"><img src="https://img.shields.io/npm/v/socket.io.svg?logo=npm" alt="NPM version"></a></p>
<p>To install the latest release:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install socket.io</span><br></pre></td></tr></table></figure>

<p>To install a specific version:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install socket.io@&lt;version&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Additional-packages（其他包）"><a href="#Additional-packages（其他包）" class="headerlink" title="Additional packages（其他包）"></a>Additional packages（其他包）</h2><p>By default, Socket.IO use the WebSocket server provided by the <a href="https://www.npmjs.com/package/ws" target="_blank" rel="noopener">ws</a> package.</p>
<p>There are 2 optional packages that can be installed alongside this package. These packages are binary add-ons which improve certain operations. Prebuilt binaries are available for the most popular platforms so you don’t necessarily need to have a C++ compiler installed on your machine.</p>
<ul>
<li><a href="https://www.npmjs.com/package/bufferutil" target="_blank" rel="noopener">bufferutil</a>: Allows to efficiently perform operations such as masking and unmasking the data payload of the WebSocket frames.</li>
<li><a href="https://www.npmjs.com/package/utf-8-validate" target="_blank" rel="noopener">utf-8-validate</a>: Allows to efficiently check if a message contains valid UTF-8 as required by the spec.</li>
</ul>
<p>To install those packages:</p>
<p>默认情况下，Socket.IO使用ws软件包提供的WebSocket服务器。</p>
<p>可以在此软件包的旁边安装2个可选软件包。 这些软件包是二进制附件，可改善某些操作。 预编译的二进制文件适用于大多数流行的平台，因此您不一定需要在计算机上安装C ++编译器。</p>
<ul>
<li><p>bufferutil：允许有效地执行操作，例如屏蔽和取消屏蔽WebSocket帧的数据有效负载。</p>
</li>
<li><p>utf-8-validate：可以有效地检查邮件是否包含规范要求的有效UTF-8。</p>
</li>
</ul>
<p>要安装这些软件包：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-optional bufferutil utf-8-validate</span><br></pre></td></tr></table></figure>

<p>Please note that these packages are optional, the WebSocket server will fallback to the Javascript implementation if they are not available. More information can be found <a href="https://github.com/websockets/ws/#opt-in-for-performance-and-spec-compliance" target="_blank" rel="noopener">here</a>.</p>
<p>请注意，这些软件包是可选的，如果WebSocket服务器不可用，它们将回退到Javascript实现。 更多信息可以在这里找到。</p>
<h2 id="Other-WebSocket-server-implementations（其他WebSocket服务器实现）"><a href="#Other-WebSocket-server-implementations（其他WebSocket服务器实现）" class="headerlink" title="Other WebSocket server implementations（其他WebSocket服务器实现）"></a>Other WebSocket server implementations（其他WebSocket服务器实现）</h2><p>Any Websocket server implementation which exposes the same API as ws (notably the <a href="https://github.com/websockets/ws/blob/master/doc/ws.md#serverhandleupgraderequest-socket-head-callback" target="_blank" rel="noopener">handleUpgrade</a> method) can be used.</p>
<p>For example, you can use the <a href="https://www.npmjs.com/package/eiows" target="_blank" rel="noopener">eiows</a> package, which is a fork of the (now deprecated) <a href="https://www.npmjs.com/package/uws" target="_blank" rel="noopener">uws</a> package:</p>
<p>可以使用任何与ws公开相同API的Websocket服务器实现（特别是handleUpgrade方法）。</p>
<p>例如，您可以使用eiows软件包，它是uws软件包（现已弃用）的分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eiows</span><br></pre></td></tr></table></figure>

<p>And then use the <code>wsEngine</code> option:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(<span class="number">3000</span>, &#123;</span><br><span class="line">  wsEngine: <span class="string">'eiows'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>This implementation “allows, but doesn’t guarantee” significant performance and memory-usage improvements over the default implementation. As usual, please benchmark it against your own usage.</p>
<p>与默认实现相比，此实现“允许但不能保证”性能和内存使用方面的重大改进。 与往常一样，请对照您自己的用法对其进行基准测试。</p>
<p>Caught a mistake? Edit this page on <a href="https://github.com/socketio/socket.io-website/blob/master/source/docs/server-installation.md" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/Socket.io/server/1.%20Installation/" data-id="ckejc3t6n0008vcxn0u5u4hsw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Socket.io/client/3. Connection lifecycle" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/Socket.io/client/3.%20Connection%20lifecycle/" class="article-date">
  <time datetime="2020-08-30T07:46:37.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/30/Socket.io/client/3.%20Connection%20lifecycle/">Connection lifecycle</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Connection-status"><a href="#Connection-status" class="headerlink" title="Connection status"></a>Connection status</h2><p>On the client-side, the <code>connected</code> attribute of the Socket object returns the current state of the connection:</p>
<p>在客户端，Socket对象的connected属性返回连接的当前状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io <span class="keyword">from</span> <span class="string">'socket.io-client'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = io();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(socket.connected); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'connect'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(socket.connected); <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'disconnect'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(socket.connected); <span class="comment">// false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Lifecycle-diagram"><a href="#Lifecycle-diagram" class="headerlink" title="Lifecycle diagram"></a>Lifecycle diagram</h2><p>Below is a diagram of the socket lifecycle. It includes the different events emitted by the socket.</p>
<p>下面是套接字生命周期的图表。 它包括套接字发出的不同事件。</p>
<p><img src="https://socket.io/images/client_connection_lifecycle.png" alt="Lifecycle diagram"></p>
<h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><p>This is the list of events that can be emitted by the Socket object.</p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>connect</td>
<td>Fired upon connection (including a successful reconnection)</td>
</tr>
<tr>
<td>disconnect</td>
<td>Fired upon disconnection</td>
</tr>
<tr>
<td>connect_error</td>
<td>Fired upon a connection error</td>
</tr>
<tr>
<td>connect_timeout</td>
<td>Fired upon a connection timeout</td>
</tr>
<tr>
<td>reconnect_attempt</td>
<td>Fired upon an attempt to reconnect</td>
</tr>
<tr>
<td>reconnect_error</td>
<td>Fired upon a reconnection attempt error</td>
</tr>
<tr>
<td>reconnect_failed</td>
<td>Fired when the client couldn’t reconnect within <code>reconnectionAttempts</code></td>
</tr>
<tr>
<td>reconnecting</td>
<td>Alias for “reconnect_attempt”</td>
</tr>
<tr>
<td>reconnect</td>
<td>Fired upon a successful reconnection</td>
</tr>
<tr>
<td>ping</td>
<td>Fired when a ping is sent to the server</td>
</tr>
<tr>
<td>pong</td>
<td>Fired when a pong is received from the server</td>
</tr>
</tbody></table>
<p>Please note that you can’t reuse those event names in your application:</p>
<p>请注意，您无法在应用程序中重复使用这些事件名称：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.emit(<span class="string">'reconnect_attempt'</span>); <span class="comment">// WARNING: will be silently discarded</span></span><br></pre></td></tr></table></figure>

<h2 id="Reconnection（重新连线）"><a href="#Reconnection（重新连线）" class="headerlink" title="Reconnection（重新连线）"></a>Reconnection（重新连线）</h2><p>By default, the client will try to reconnect forever.</p>
<p>Here is the default configuration:</p>
<p>默认情况下，客户端将尝试永久重新连接。</p>
<p>这是默认配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(&#123;</span><br><span class="line">  reconnection: <span class="literal">true</span>,             <span class="comment">// whether to reconnect automatically</span></span><br><span class="line">  reconnectionAttempts: <span class="literal">Infinity</span>, <span class="comment">// number of reconnection attempts before giving up</span></span><br><span class="line">  reconnectionDelay: <span class="number">1000</span>,        <span class="comment">// how long to initially wait before attempting a new 		      reconnection</span></span><br><span class="line">  reconnectionDelayMax: <span class="number">5000</span>,     <span class="comment">// maximum amount of time to wait between reconnection attempts. Each attempt increases the reconnection delay by 2x along with a randomization factor</span></span><br><span class="line">  randomizationFactor: <span class="number">0.5</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Delay between two consecutive attempts:</p>
<ul>
<li>1st attempt: <code>1000 +/- 500 ms</code></li>
<li>2nd attempt: <code>2000 +/- 1000 ms</code></li>
<li>3nd attempt: <code>4000 +/- 2000 ms</code></li>
<li>following attempts: <code>5000 +/- 2500 ms</code></li>
</ul>
<p>The randomization factor helps smooth the load induced by the reconnection attempts of multiple clients, in case a server goes down.</p>
<p>Sample lifecycle:</p>
<p>两次连续尝试之间的延迟：</p>
<ul>
<li><p>第一次尝试：1000 +/- 500毫秒</p>
</li>
<li><p>第二次尝试：2000 +/- 1000毫秒</p>
</li>
<li><p>第三次尝试：4000 +/- 2000毫秒</p>
</li>
<li><p>以下尝试：5000 +/- 2500毫秒</p>
</li>
</ul>
<p>如果服务器发生故障，随机因素有助于平滑由多个客户端的重新连接尝试引起的负载。</p>
<p>样本生命周期：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- connect            // the client successfully establishes a connection to the server.</span><br><span class="line">- disconnect         // some bad thing happens (the server crashes, for example).</span><br><span class="line">- reconnect_attempt  // after a given delay, the client tries to reconnect.</span><br><span class="line">- reconnect_error    // the first attempt fails.</span><br><span class="line">- reconnect_attempt  // after a given delay, the client tries to reconnect again</span><br><span class="line">- connect            // the client successfully restore the connection to the server</span><br></pre></td></tr></table></figure>

<p>Example with <code>reconnectionAttempts: 3</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- connect            // the client successfully establishes a connection to the server</span><br><span class="line">- disconnect         // some bad thing happens (the client goes offline, for example)</span><br><span class="line">- reconnect_attempt  // after a given delay, the client tries to reconnect</span><br><span class="line">- reconnect_error    // the first attempt fails</span><br><span class="line">- reconnect_attempt  // after a given delay, the client tries to reconnect</span><br><span class="line">- reconnect_error    // the second attempt fails</span><br><span class="line">- reconnect_attempt  // after a given delay, the client tries to reconnect</span><br><span class="line">- reconnect_error    // the third attempt fails</span><br><span class="line">- reconnect_failed   // the client won't try to reconnect anymore</span><br></pre></td></tr></table></figure>

<h2 id="Disabling-the-default-reconnection-logic（禁用默认的重新连接逻辑）"><a href="#Disabling-the-default-reconnection-logic（禁用默认的重新连接逻辑）" class="headerlink" title="Disabling the default reconnection logic（禁用默认的重新连接逻辑）"></a>Disabling the default reconnection logic（禁用默认的重新连接逻辑）</h2><p>Reconnection can be disabled, in case you want to provide your own reconnection logic:</p>
<p>如果您想提供自己的重新连接逻辑，则可以禁用重新连接：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> socket = io(&#123;</span><br><span class="line">  reconnection: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'connect_error'</span>, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    socket.connect();</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'disconnect'</span>, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    socket.connect();</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Caught a mistake? Edit this page on <a href="https://github.com/socketio/socket.io-website/blob/master/source/docs/client-connection-lifecycle.md" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/30/Socket.io/client/3.%20Connection%20lifecycle/" data-id="ckejc3t6l0005vcxn6yv9gmdh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/GridManager/" rel="tag">GridManager</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux-%E4%B8%BA%E7%9F%A5%E7%AC%94%E8%AE%B0/" rel="tag">Linux 为知笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/GridManager/" style="font-size: 10px;">GridManager</a> <a href="/tags/Linux-%E4%B8%BA%E7%9F%A5%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">Linux 为知笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/30/Socket.io/client/2.%20Initialization/">Initialization</a>
          </li>
        
          <li>
            <a href="/2020/08/30/Socket.io/server/5.%20Using%20multiple%20nodes/">Using multiple nodes</a>
          </li>
        
          <li>
            <a href="/2020/08/30/Socket.io/Documentation/1.%20Introduction/">Introduction</a>
          </li>
        
          <li>
            <a href="/2020/08/30/Socket.io/server/3.%20Namespaces/">Namespaces</a>
          </li>
        
          <li>
            <a href="/2020/08/30/Socket.io/Introduction/">Introduction</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>